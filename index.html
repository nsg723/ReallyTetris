<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Really Tetris — Live High Score</title>

<style>
    body {
        background: #C0C0C0;
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        height: 100vh;
    }

    #game-container {
        width: 500px;
        max-width: 95vw;
        margin-top: 0;
        transform: scale(1);
        transform-origin: top center;
        border: 3px solid #000;
        background: #E0E0E0;
    }

    @media (max-height: 720px) { #game-container { transform: scale(0.9); } }
    @media (max-height: 650px) { #game-container { transform: scale(0.8); } }
    @media (max-height: 580px) { #game-container { transform: scale(0.7); } }
    @media (max-height: 500px) { #game-container { transform: scale(0.6); } }

    #title {
        background: linear-gradient(#FFFFFF, #DDDDDD);
        color: black;
        font-weight: bold;
        text-align: center;
        padding: 10px;
        border-bottom: 3px solid black;
        font-size: 20px;
    }

    #board {
        width: 300px;
        height: 600px;
        border: 3px solid black;
        margin: 15px auto;
        background: #FFFFFF;
        image-rendering: pixelated;
        box-sizing: content-box;
    }

    .cell {
        width: 30px;
        height: 30px;
        float: left;
        border: 1px solid #999;
        box-sizing: border-box;
    }

    #stats { text-align:center; margin-top:10px; padding-bottom:12px; }
    #high-stats { text-align:center; margin-top:5px; }
    .game-over {
      text-align:center;
      padding:8px 0;
      color:#900;
      font-weight:bold;
    }
</style>
</head>
<body>

<div id="game-container">
    <div id="title">REALLY TETRIS</div>
    <div id="board" aria-label="tetris board"></div>

    <div id="stats">
      Score: <span id="score">0</span> | Lines: <span id="lines">0</span>
      <div id="high-stats">
        High Score: <span id="high-score">0</span> | High Lines: <span id="high-lines">0</span>
      </div>
      <div id="gameoverText" class="game-over" style="display:none;">GAME OVER — Press R to Restart</div>
    </div>
</div>

<script>
// CONFIG
const COLS = 10;
const ROWS = 20;

// DOM
const boardElem = document.getElementById('board');
const scoreEl = document.getElementById('score');
const linesEl = document.getElementById('lines');
const highScoreEl = document.getElementById('high-score');
const highLinesEl = document.getElementById('high-lines');
const gameoverText = document.getElementById('gameoverText');

// STATE
let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
let current = null;
let gameOver = false;
let score = 0;
let linesCleared = 0;

// Load highs
let highScore = parseInt(localStorage.getItem("highScore")) || 0;
let highLines = parseInt(localStorage.getItem("highLines")) || 0;
highScoreEl.textContent = highScore;
highLinesEl.textContent = highLines;

// Prevent arrow scrolling
window.addEventListener("keydown", function(e) {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"," "].includes(e.code || e.key)) {
        e.preventDefault();
    }
}, { passive: false });

// -----------------------------
// Piece generator (compact random walk, 4-way connectivity)
// -----------------------------
function generatePiece() {
    const sizes = [[2,2],[2,3],[3,2],[3,3]];
    const [h, w] = sizes[Math.floor(Math.random() * sizes.length)];
    const maxBlocks = h * w;
    const blockCount = Math.floor(Math.random() * (maxBlocks - 1)) + 2;
    const shape = Array.from({ length: h }, () => Array(w).fill(0));

    let r = Math.floor(Math.random() * h);
    let c = Math.floor(Math.random() * w);
    shape[r][c] = 1;
    const frontier = [[r,c]];

    while (shape.flat().reduce((a,b)=>a+b,0) < blockCount && frontier.length) {
        const [cr, cc] = frontier.pop();
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]].sort(()=>Math.random()-0.5);
        for (const [dr, dc] of dirs) {
            const nr = cr + dr;
            const nc = cc + dc;
            if (nr >=0 && nr < h && nc >=0 && nc < w && shape[nr][nc] === 0) {
                shape[nr][nc] = 1;
                frontier.push([nr,nc]);
                break;
            }
        }
    }

    const colors = ["#FF0000","#00AAFF","#00CC00","#FF00FF","#FFA500","#7700FF","#009999"];
    return { shape, color: colors[Math.floor(Math.random()*colors.length)] };
}

function rotateShape(shape) {
    const h = shape.length, w = shape[0].length;
    const out = Array.from({ length: w }, () => Array(h).fill(0));
    for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
            out[x][h-1-y] = shape[y][x];
        }
    }
    return out;
}

// -----------------------------
// Collision and placement
// -----------------------------
function canPlace(piece, rr, cc, shapeOverride = null) {
    const shape = shapeOverride || piece.shape;
    for (let r=0;r<shape.length;r++){
        for (let c=0;c<shape[0].length;c++){
            if (shape[r][c] === 1) {
                const br = rr + r;
                const bc = cc + c;
                if (bc < 0 || bc >= COLS) return false;
                if (br >= ROWS) return false;
                if (br >= 0 && board[br][bc]) return false;
            }
        }
    }
    return true;
}

function mergePiece(piece) {
    let landedBlocks = 0;
    for (let r=0;r<piece.shape.length;r++){
        for (let c=0;c<piece.shape[0].length;c++){
            if (piece.shape[r][c] === 1) {
                const br = piece.r + r;
                const bc = piece.c + c;
                if (br >= 0 && br < ROWS && bc >=0 && bc < COLS) {
                    board[br][bc] = piece.color;
                    landedBlocks++;
                }
            }
        }
    }
    score += landedBlocks;
    updateStats();
}

function clearLines() {
    let cleared = 0;
    for (let y = ROWS-1; y >= 0; y--) {
        if (board[y].every(cell => cell !== 0)) {
            cleared++;
            board.splice(y, 1);
            board.unshift(new Array(COLS).fill(0));
            y++;
        }
    }
    if (cleared > 0) {
        linesCleared += cleared;
        const pointsForLines = {1:40, 2:100, 3:300, 4:1200};
        score += (pointsForLines[cleared] || (cleared * 100));
        updateStats();
    }
}

function updateStats() {
    scoreEl.textContent = score;
    linesEl.textContent = linesCleared;

    // Live high score/lines update
    if (score > highScore) {
        highScore = score;
        highScoreEl.textContent = highScore;
        localStorage.setItem("highScore", highScore);
    }
    if (linesCleared > highLines) {
        highLines = linesCleared;
        highLinesEl.textContent = highLines;
        localStorage.setItem("highLines", highLines);
    }
}

// -----------------------------
// Spawning & game-over
// -----------------------------
function spawnPiece() {
    const p = generatePiece();
    p.c = Math.floor((COLS - p.shape[0].length) / 2);
    p.r = -p.shape.length;
    if (!canPlace(p, p.r, p.c)) {
        onGameOver();
        return null;
    }
    return p;
}

function onGameOver(){
    gameOver = true;
    gameoverText.style.display = 'block';
}

// -----------------------------
// Controls
// -----------------------------
document.addEventListener('keydown', (e) => {
    if (gameOver) {
        if (e.key.toLowerCase() === 'r') restartGame();
        return;
    }
    if (!current) return;
    if (e.code === "ArrowLeft" && canPlace(current, current.r, current.c - 1)) current.c--;
    else if (e.code === "ArrowRight" && canPlace(current, current.r, current.c + 1)) current.c++;
    else if (e.code === "ArrowDown" && canPlace(current, current.r + 1, current.c)) current.r++;
    else if (e.code === "ArrowUp") {
        const rotated = rotateShape(current.shape);
        const offsets = [0, -1, 1];
        for (const off of offsets) {
            if (canPlace(current, current.r, current.c + off, rotated)) {
                current.shape = rotated;
                current.c += off;
                break;
            }
        }
    }
    draw();
});

document.addEventListener('keydown', (e) => {
    if (gameOver) return;
    if (e.code === "Space" || e.key === " ") {
        while (current && canPlace(current, current.r + 1, current.c)) current.r++;
        if (current) {
            mergePiece(current);
            clearLines();
            current = spawnPiece();
        }
        draw();
    }
});

// -----------------------------
// Game loop
// -----------------------------
let gravityMs = 500;
setInterval(() => {
    if (gameOver || !current) return;
    if (canPlace(current, current.r + 1, current.c)) current.r++;
    else {
        mergePiece(current);
        clearLines();
        current = spawnPiece();
    }
    draw();
}, gravityMs);

// -----------------------------
// Drawing
// -----------------------------
function draw() {
    boardElem.innerHTML = '';
    const temp = board.map(r => r.slice());
    if (current && current.shape) {
        for (let r=0;r<current.shape.length;r++){
            for (let c=0;c<current.shape[0].length;c++){
                if (current.shape[r][c] === 1) {
                    const br = current.r + r;
                    const bc = current.c + c;
                    if (br >= 0 && br < ROWS && bc >= 0 && bc < COLS) temp[br][bc] = current.color;
                }
            }
        }
    }

    for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.style.background = temp[r][c] === 0 ? '#FFFFFF' : temp[r][c];
            boardElem.appendChild(cell);
        }
    }
}

// -----------------------------
// Restart
// -----------------------------
function restartGame() {
    board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    current = null;
    gameOver = false;
    score = 0;
    linesCleared = 0;
    updateStats();
    gameoverText.style.display = 'none';
    current = spawnPiece();
    draw();
}

// -----------------------------
// Init
// -----------------------------
current = spawnPiece();
draw();
</script>
</body>
</html>
